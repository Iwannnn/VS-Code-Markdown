# 深入理解计算机存储器层次结构

## 一、存储技术
### 1. 随机访问存储器

随机访问存储器分为两类：静态的和动态的。静态RAM(SRAM)比动态RAM(DRAM)更快，但也贵的多。SRAM作为高速缓存存储器，既可以再CPU芯片上，也可以在片下。DRAM用来作为主存以及图形系统的帧缓冲区。典型的，一个桌面系统的SRAM不会超过几兆字节，但是DRAM却又几百或几千兆字节，

**(1) 静态RAM**

SRAM将每个位存储在一个双稳态的(bistable)存储单元里。每个单元是用一个六晶体管电路来实现的。每个电路有这样一个属性，它可以无限期的保持在两个不同的电压配置(configuration)或状态(state)直以。其他任何状态都属不稳定的——从不稳定状态开始，电路会迅速转移到两个稳定状态中的一个。这样一个存储器单元类似于一个倒转的钟摆

**(2) 动态RAM**

DRAM将每个位存储位对一个电容的充电。这个电容非常小，大约只有30毫微微法拉。DRAM可以制造的而非常密集——每个单元由一个电容和一个访问晶体管组成。它和SRAM不同，DRAM存储单元对干扰非常敏感。当电容电压被扰乱之后，它就永远不会恢复了。


### 2. 磁盘存储
磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，比从DRAM读慢了10万倍，比从SRAM读满了100万倍。

**(1) 磁盘构造**
    
磁盘是由盘片(platter)构成的．每个盘片有两面或者称为表面(suffer)．表面種盖着磁性记录材料．盘片中央有一个可以旋转的主轴(spindle)，它使得盘片以固定的旋转速率(rotational rate)旋转．通常是5400～15000转每分钟（RevolutionPerMinute,RPM)。磁盘常包含一个或多个这样的盘片，并封装在一个密封的容器内。
  
每个表面是由一组称为磁道(track)的同心组成的．每个磁道被划分为一组扇区(sector)。每个扇区包含相等数量的数据位(通常是512字节)，这些数据编码在区上的磁性材料中．扇区之间由一些间隙（gap）分开，这些间隙中不存储数据位。间隙存储用来标识扇区的格式化位。
  
磁盘是由一个或多个叠放在一起的盘片组成的，它们被封装在一个巒封的包装里。整个装置通常被称为磁盘驱动器(diskdrive)，我们通常简称为磁盘(disk)。有时，我们会称磁盘为旋栲磁盘(rotating disk)•以使之区别于基于闪存的态硬盘(SSD)，SSD是没有移动部分的。

磁盘造商涌常用术语柱面(cylinder)来描述多个盘片驱动器的构造，这里，柱面是所有盘片表面上到主轴中心的距离相等的磁道的集合·例如，如果一个驱动器有三个盘片和六个面，每个表面上的磁道的编号都是一致的，那么柱面k就是6个磁道k的集合。


**(2) 磁盘容量**

一个磁盘上可以记录的最大位数称为它的最大容量，或者简称为容量，磁盘容量是由一下技术因素决定的。

- 记录密度(recording density)(位/英寸): 磁道一英寸的段中可以放入的尾数。
- 磁道密度(track density)(道/英寸): 从盘片中心出发半径上一英寸的段内可以有的磁道数。
- 面密度(areal density)(位/平方英寸): 记录密度和磁道密度的乘积。
  
磁盘容量公式：

磁盘容量=字节数/扇区 * 平均扇区数/磁道 * 磁道数/磁面 * 表面数/盘片 * 盘片数/磁盘

**(3) 磁盘操作**

磁盘用读/写头(read/write head)来读写存储在磁性表面的位，而读写头连接到一个转动臂(actuator arm)一端。通过沿着半径轴前后移动这个转动臂，驱动器可以将读/写头定位到盘面上的任何磁道上。这样的机械运动成为寻道(seek)。一旦读/写头定位到了期望的磁道上，那么当磁道上的每个位通过他的下面是，读/写头可以感知到这个位的值(读该位),也可以修改这个位值(写该位)。有多个盘片的磁盘针对每个盘面都有一个独立的读/写头。该读/写头垂直排列，一致行动，任何时候，所有的读/写头都位于同一个柱面上。

### 3. 固态硬盘

固态硬盘(Solid State Disk SSD)是一种基于闪存的存储技术，在某些情况下是传统旋转磁盘的极有吸引力的替代品。SSD封装插到I/O总线上标准硬盘插槽(通常是USB或SATA)中，行为就和其他硬盘一样处理来自CPU的读写逻辑磁盘块的请求。一个SSD封装由一个或多个闪存芯片和闪存翻译层(flash translation layer)组成，闪存芯片替代传统的旋转磁盘中的机器驱动器，而闪存翻译层是一个硬件/固件设备，扮演与磁盘控制器相同的角色，将对那个逻辑块的请求翻译成对底层物理设备的访问。

## 二、局部性
一个编写良好的计算机程序常常具有良好的局部性(locality)。也就是，他们倾向于引用临近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为局部性原理(principle of locality),是一个持久的概念，对硬件和软件系统的设计和性能都有极大的影响。

局部性通常有两种不同的形式:时间局部性(temporal locality)和空间局部性(spatial locality)。在一个具有良好的时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。再一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能再不远的将来引用附近的一个内存位置。

### 1. 对数据引用的局部性

下面这个程序变量```sum```再每次循环迭代中被引用一次，因此，对于```sum```来说，有好的时间局部性。另一方面，因为```sum```是标量，对于```sum```来说，没有空间局部性。

```c
int sumvec(int v[N]){
	int i,sum=0;
	for(i=0;i<N;++i){
		sum += v[i];
	}
	return sum;
}
```
上面程序顺序访问每一个向量元素的函数，具有步长位1的引用模式(stride-1 reference pattern)(相对于元素的大小)。在一个连续向量中，每隔k个元素进行访问，就成为步长为k的引用模式。步长位1的引用模式是程序中空间局部性的常见和重要来源。一般而言，随步长增加，空间局部性下降。

对于引用多维数组的程序来说，步长也是一个很重要的问题。```sumarrayrow```双重嵌套循环按照行优先顺序(row-major order)读数组的元素。他具有良好的空间局部性。因为他按照数组被存储的行优先顺序来访问这个数组，其结果是得到一个很好的步长位1的引用模式。

```c
int sumarrayrows(int a[M][N]){
	int i,j,sum=0;

	for(i=0;i<M;++i){
		for(j=0;j<N;++j){
			sum+=a[i][j];
		}
	}

	return sum;
}
```

一些小改动会对他的局部性产生很大影响,```sumarraycols```函数按列顺序来扫描数组。因为再```c```语言中数组是按行来存放的，结果就得到了步长位N的引用模式。
```c
int sumarraycols(int a[M][N]){
	int i,j,sum=0;

	for(j=0;i<N;++J){
		for(i=0;j<M;++i){
			sum+=a[i][j];
		}
	}

	return sum;
}
```

### 2. 取指令的局部性

因为程序指令是存放在内存中的，CPU必须取出(读出)这些指令，所以我们也能够评价一个程序关于取指令的局部性。代码区别于程序数据的一个重要属性是在运行时他是不能被修改的。当程序正在执行时，CPU只从内存中读出他的指令。CPU很少会重写或修改这些指令

### 3. 局部性小结

- 重复引用相同变量的程序具有良好的时间局性
- 对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在内存中以大步长跳来跳去的程序空间局部性会很差。
- 对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越少，局部性越好。

## 三、存储器层次结构
1. 缓存
2. 

## 四、高速缓存存储器
1. 通用的高速缓存存储器组织结构
2. 直接映射高速缓存
3. 组相联高速缓存
4. 全相联高速缓存
5. 